---
slug: sharing-event-definitions-multiple-contracts-rust
title: How to Share Event Definitions Between Multiple Contracts in Rust using the ink! framework
authors: [nicolad]
---

import Svg from './ink.svg';

<Svg style={{ width: '100%', height: '400px' }} />

When working on multiple contracts, it can be challenging to share event definitions between them since events can only be defined in the ink! module scope directly. However, there are some workarounds that can make it possible to reuse event definitions.

One approach is to define the event structs in a separate module and then include them in each contract that needs them. This way, the events can be defined independently of any specific contract and can be used by multiple contracts. However, this approach requires duplicating the event definitions in each contract, which can be tedious and error-prone.

Another approach is to define the event structs in a shared crate that can be imported by multiple contracts. This way, the event definitions can be kept in a central location and reused across contracts without duplication. However, this approach also requires additional setup to ensure that the contracts can access the shared crate.

A third approach is to use ink!'s trait system to define event emitting methods in a shared trait and then implement the trait in each contract that needs to emit the events. This way, the event definitions can be kept in a shared trait and reused across contracts without duplication. Here is an example of how to do this:

First, define the event structs in a separate module:

```rust
#[ink(event)]
pub struct Transfer {
    #[ink(topic)]
    from: Option<AccountId>,
    #[ink(topic)]
    to: Option<AccountId>,
    value: Balance,
}

#[ink(event)]
pub struct Approval {
    #[ink(topic)]
    owner: AccountId,
    #[ink(topic)]
    spender: AccountId,
    value: Balance,
}
```

Next, define a shared trait that includes methods for emitting the events:

```rust
pub trait EventEmitting {
    fn emit_transfer_event(&self, from: Option<AccountId>, to: Option<AccountId>, value: Balance);
    fn emit_approval_event(&self, owner: AccountId, spender: AccountId, value: Balance);
}

impl<T: Environment> EventEmitting for InkStorage<T> {
    fn emit_transfer_event(&self, from: Option<AccountId>, to: Option<AccountId>, value: Balance) {
        self.env().emit_event(Transfer {
            from,
            to,
            value,
        });
    }

    fn emit_approval_event(&self, owner: AccountId, spender: AccountId, value: Balance) {
        self.env().emit_event(Approval {
            owner,
            spender,
            value,
        });
    }
}
```

Finally, implement the EventEmitting trait in each contract that needs to emit the events:

```rust
#[ink(storage)]
pub struct MyContract {
    ...
}

impl MyContract {
    ...
}

impl EventEmitting for MyContract {
    fn emit_transfer_event(&self, from: Option<AccountId>, to: Option<AccountId>, value: Balance) {
        InkStorage::<Self>::emit_transfer_event(self, from, to, value);
    }

    fn emit_approval_event(&self, owner: AccountId, spender: AccountId, value: Balance) {
        InkStorage::<Self>::emit_approval_event(self, owner, spender, value);
    }
}
```

With this setup, the event emitting methods can be shared between multiple contracts, allowing them to reuse the same event definitions without duplication.
