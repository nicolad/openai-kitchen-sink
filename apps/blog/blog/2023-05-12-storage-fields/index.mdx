---
slug: storage-fields
title: Understanding Storage Fields in ink! Smart Contracts
authors: [nicolad]
---

import Svg from './rust.svg';

<Svg
  style={{
    width: '100%',
    height: '500px',
  }}
/>

In ink!, the Uniswap V2 Pair contract has storage fields that need to be implemented. These fields include `factory`, `token0`, `token1`, `reserve0`, `reserve1`, `blockTimestampLast`, `price0CumulativeLast`, `price1CumulativeLast`, and `kLast`. We'll explore how to implement these storage fields in ink!.

## Storage Fields Overview

Let's take a closer look at the storage fields required for the Uniswap V2 Pair contract:

```solidity
address public factory;
address public token0;
address public token1;

uint112 private reserve0;           // uses single storage slot, accessible via getReserves
uint112 private reserve1;           // uses single storage slot, accessible via getReserves
uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves

uint public price0CumulativeLast;
uint public price1CumulativeLast;
uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event
```

In ink!, we'll be using Substrate primitive types for our storage fields. Here's a conversion table between Solidity and ink! types:

| Solidity                                | ink!                         |
| --------------------------------------- | ---------------------------- |
| uint256                                 | U256                         |
| any other uint                          | u128 (or lower)              |
| address                                 | AccountId                    |
| mapping(key => value)                   | Mapping(key, value)          |
| mapping(key1 => mapping(key2 => value)) | Mapping((key1, key2), value) |

## Creating the Storage Struct

To implement the storage fields, we'll create a storage struct called `Data` in the `./logics/impls/pair/data.rs` file. This struct will contain all the required fields:

```rust
use openbrush::traits::{AccountId, Balance, Timestamp};

pub const STORAGE_KEY: u32 = openbrush::storage_unique_key!(Data);

#[derive(Debug)]
#[openbrush::upgradeable_storage(STORAGE_KEY)]
pub struct Data {
    pub factory: AccountId,
    pub token_0: AccountId,
    pub token_1: AccountId,
    pub reserve_0: Balance,
    pub reserve_1: Balance,
    pub block_timestamp_last: Timestamp,
    pub price_0_cumulative_last: Balance,
    pub price_1_cumulative_last: Balance,
    pub k_last: u128,
}
```

In the code above, we define the `Data` struct and mark it with the `openbrush::upgradeable_storage` attribute. This attribute specifies the `STORAGE_KEY`, which is a unique key generated by Openbrush based on the struct's name and file path. We import the required fields from `openbrush::traits`.

## Implementing the Default Trait

Next, we'll implement the `Default` trait for the `Data` struct. This allows us to define the default values for each field:

```rust
impl Default for Data {
    fn default() -> Self {
        Self {
            factory: ZERO_ADDRESS.into(),
            token_0: ZERO_ADDRESS.into(),
            token_1: ZERO_ADDRESS.into(),
            reserve_0: 0,
            reserve_1: 0,
            block_timestamp_last: 0,
            price_0_cumulative_last: Default::default(),
            price_1_cumulative_last: Default::default(),
            k_last: Default::default(),
        }
    }
}
```

In the `default()` function, we set the initial values for each field. The `ZERO_ADDRESS` is converted into the `AccountId` type using the `.into()` conversion method. The numeric fields are initialized to their default values, and the `Default::default()` method is used for the remaining fields.

With the storage struct `Data` and the `Default` implementation in place, we have successfully implemented the storage fields in ink!. These fields can now be used within the Uniswap V2 Pair contract to store and access the necessary data.

By leveraging ink!'s primitive types and the Openbrush framework, we can efficiently manage storage fields in ink! contracts, providing flexibility and compatibility with Solidity contracts like the Uniswap V2 Pair contract.
